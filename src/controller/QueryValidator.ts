import { InsightError } from "./IInsightFacade";

export interface PossibleOption {
	COLUMNS: string[]; //KEY[] | string[];
	ORDER?: string | SortObject;
}

export interface InsightQuery {
	WHERE: {};
	OPTIONS: {};
	TRANSFORMATIONS?: {}; // create Transformations interface for C2
}

export interface Transformations {
	GROUP: Group;
	APPLY: Apply;
}

// export interface Group {
// 	[keys: string]: string[]; //KEY_LIST
// }
//
// export interface Apply {
// 	[rules: string]: ApplyRule[]; //APPLYRULE_LIST
// }

export interface Group {
	GROUP: string[]; //KEY_LIST
}

export interface Apply {
	APPLY: ApplyRule[]; //APPLYRULE_LIST
}

export interface ApplyRule {
	[applykey: string]: {
		[APPLYTOKEN: string]: string; //KEY
	};
}

export interface SortObject {
	dir: "UP" | "DOWN";
	keys: string[]; //KEY[]
}

export type LogicComparators = "AND" | "OR";
export type MComparators = "LT" | "GT" | "EQ";

export type Filters = LOGICCOMPARISON | MCOMPARISON | SCOMPARISON | NEGATION;

export type LOGICCOMPARISON = {
	//want this to be an interface to maintain structure of object
	[comparator in LogicComparators]?: Filters[];
	//non-empty array
};

export type MCOMPARISON = {
	[comparator in MComparators]?: {
		[mkey in MKEY]?: number;
	};
};

export interface SCOMPARISON {
	IS: {
		[skey in SKEY]: string;
	};
}
export interface NEGATION {
	NOT: Filters;
}

//this block of code is generated by an AI tool

export type SKEY = `"${string}_${ValidSFields}"`;
export type MKEY = `"${string}_${ValidMFields}"`;

//export type KEY = MKEY | SKEY;
//end of AI generated code block

export type ValidMFields = "avg" | "pass" | "fail" | "audit" | "year" | "lat" | "lon" | "seats";
export type ValidSFields =
	| "dept"
	| "id"
	| "instructor"
	| "title"
	| "uuid"
	| "fullname"
	| "shortname"
	| "number"
	| "name"
	| "address"
	| "type"
	| "furniture"
	| "href";

const LOGIC = new Set(["AND", "OR"]);
const NEGATION = new Set(["NOT"]);
const SCOMPARATOR = new Set(["IS"]);
const MCOMPARATOR = new Set(["LT", "GT", "EQ"]);
const APPLYTOKEN = new Set(["MAX", "MIN", "AVG", "COUNT", "SUM"]);

export default class QueryValidator {
	private query: unknown;
	private datasetID: string;

	constructor(query: unknown) {
		this.query = query;
		this.datasetID = "";
		this.validateQuery();
	}

	public validateQuery(): void {
		if (this.query === null) {
			throw new InsightError("query is null");
		}

		if (typeof this.query !== "object") {
			throw new InsightError(`query is not an object)`);
		}

		//const queryTree:unknown = getQuery(this.query);

		if (Object.keys(this.query).length === 0) {
			throw new InsightError("empty query");
		}
		if (!Object.keys(this.query).includes("WHERE")) {
			throw new InsightError("query does not include WHERE clause");
		}
		if (!Object.keys(this.query).includes("OPTIONS")) {
			throw new InsightError("query does not include OPTIONS clause");
		}

		const threeClauses = 3; // 3 clauses: WHERE, OPTIONS, TRANSFORMATIONS? (optional) for C2
		//const twoClauses = 2; // 2 clauses: WHERE, OPTIONS for C1

		const expectedClauses = Object.keys(this.query).includes("TRANSFORMATIONS") ? threeClauses : 2;

		if (Object.keys(this.query).length > expectedClauses) {
			throw new InsightError("query has more clauses than expected");
		}

		const queryTree = this.query as InsightQuery;
		this.datasetID = this.extractDatasetId(queryTree); //required here for checking that a query only references one dataset

		this.validateWhere(queryTree.WHERE);
		this.validateOptions(queryTree.OPTIONS as PossibleOption);

		if (queryTree.TRANSFORMATIONS) {
			const transformations = queryTree.TRANSFORMATIONS as Transformations;
			this.validateTransformations(transformations);
			this.validateColumnsWithTransformations(queryTree.OPTIONS as PossibleOption, transformations);
		}
	}

	public validateWhere(where: Filters): void {
		if (typeof where !== "object") {
			throw new InsightError("WHERE clause must be an object");
		} //Negation test failing this condition

		if (Object.keys(where).length === 0) {
			return; // Empty WHERE clause is valid as per spec
		}
		const [filterType, filterValue] = Object.entries(where)[0];
		//gets first key-value pair in WHERE object

		if (LOGIC.has(filterType)) {
			this.validateLogicComparison(filterValue as Filters[]);
		} else if (MCOMPARATOR.has(filterType)) {
			this.validateMComparison(filterValue as MCOMPARISON);
		} else if (SCOMPARATOR.has(filterType)) {
			this.validateSComparison(filterValue as SCOMPARISON);
		} else if (NEGATION.has(filterType)) {
			this.validateWhere(filterValue);
			//this.validateNegation(filterValue as NEGATION);
		} else {
			throw new InsightError(`Invalid filter type: ${filterType}`);
		}
	}

	public validateOptions(options: PossibleOption): void {
		//this block of code is generated by AI
		const columns = options.COLUMNS;
		if (!options.COLUMNS || !Array.isArray(columns) || columns.length === 0) {
			throw new InsightError("OPTIONS does not have COLUMNS array");
		}

		// const validFields = ["avg", "pass", "fail", "audit", "year", "dept", "id", "instructor", "title", "uuid"];
		const prefix = this.datasetID + "_";

		columns.forEach((key) => {
			if (!this.isValidKey(key, prefix)) {
				throw new InsightError(`Invalid key in columns: ${key}`);
			}
		});

		//end of AI generated code block

		if (options.ORDER !== undefined) {
			if (typeof options.ORDER === "string") {
				this.validateOrder(options.ORDER, columns);
			} else {
				this.validateSort(options.ORDER, columns);
			}
		}
	}

	private validateLogicComparison(logic: Filters[]): void {
		if (!Array.isArray(logic) || logic.length === 0) {
			throw new InsightError("Logic comparison must be a non-empty array");
		}
		logic.forEach((subFilter) => this.validateWhere(subFilter));
	}

	// private validateNegation(negation: NEGATION): void {
	// 	this.validateWhere(negation.NOT)
	// 	//this.validateWhere(Object.values(negation.NOT)[0] as Filters);
	// }

	private validateMComparison(comparison: any): void {
		if (typeof comparison !== "object" || comparison === null) {
			throw new InsightError(`MCOMPARISON must be an object.`);
		}
		//the following block of code is inspired by code generated by AI tool
		const entries = Object.entries(comparison);
		if (entries.length !== 1) {
			throw new InsightError("MComparison must have exactly one key-value pair");
		}

		const [key, value] = entries[0];

		// Check if key starts with idstring_ and has one of the valid field names
		//const validFields = ["avg", "pass", "fail", "audit", "year"];
		const prefix = this.datasetID + "_";

		if (!this.isValidKey(key, prefix)) {
			throw new InsightError(`Invalid key in columns: ${key}`);
		}

		//end of specified code block
		if (!key.startsWith(prefix) || !(key.substring(prefix.length) as ValidMFields)) {
			throw new InsightError(`Invalid MComparator: ${key}`);
		}

		if (typeof value !== "number") {
			throw new InsightError(`MComparison value must be a number: ${value}.`);
		}
	}

	private validateSComparison(SComparison: SCOMPARISON): void {
		if (typeof SComparison !== "object" || SComparison === null) {
			throw new InsightError("SComparison must be an object.");
		} //is this necessary?

		//this block of code is generated by AI tool
		const entries = Object.entries(SComparison);
		//console.log(entries);
		if (entries.length !== 1) {
			throw new InsightError("SComparison must have exactly one key-value pair");
		}

		const [key, value] = entries[0];

		//const validFields = ["dept", "id", "instructor", "title", "uuid"];
		const prefix = this.datasetID + "_";

		if (!this.isValidKey(key, prefix)) {
			throw new InsightError(`Invalid key in columns: ${key}`);
		}

		// end of AI generated code block

		// console.log(key);
		// console.log(!key.startsWith(prefix));
		if (!key.startsWith(prefix) || !(key.substring(prefix.length) as ValidMFields)) {
			//!validFields.includes(key.substring(prefix.length))) {
			throw new InsightError(`Invalid SComparator: ${key}`);
		}

		if (typeof value !== "string") {
			throw new InsightError("SComparison value must be a string: ${value}");
		}

		this.validateWildcardString(value);
	}

	private validateWildcardString(wildcardString: string): void {
		const asteriskCount = this.countOccurrences(wildcardString, "*");

		if (asteriskCount > 2) {
			throw new InsightError("More than two asterisks");
		}

		// this is allowed
		// if (wildcardString === "") {
		// 	throw new InsightError("SComparator is empty string");
		// }

		if (asteriskCount === 0) {
			return;
		} else if (asteriskCount === 1) {
			if (wildcardString === "*" || wildcardString.startsWith("*") || wildcardString.endsWith("*")) {
				return;
			}
		} else if (asteriskCount === 2) {
			if (wildcardString.startsWith("*") && wildcardString.endsWith("*") && wildcardString.length > 2) {
				return;
			}
			// "*text*" - must start and end with * and have something in between
		}

		throw new InsightError("Invalid Wildcard String");
	}

	// this block of code is generated by AI
	private countOccurrences(str: string, char: string): number {
		let count = 0;

		for (const c of str) {
			if (c === char) {
				count++;
			}
		}

		return count;
	}
	// end of AI generated code block

	private validateOrder(order: string, columns: string[]): void {
		if (!columns.includes(order)) {
			throw new InsightError(`ORDER key not in COLUMNS: ${order}`);
		}
	}

	public extractDatasetId(query: InsightQuery): string {
		const columns = (query.OPTIONS as PossibleOption).COLUMNS;
		if (columns.length === 0) {
			throw new InsightError("COLUMNS array is empty");
		}
		const firstColumn = columns[0];
		const datasetId = firstColumn.split("_")[0];
		if (!datasetId) {
			throw new InsightError("Invalid dataset ID");
		}
		return datasetId;
	}

	public getDatasetID(): string {
		return this.datasetID;
	}

	private validateTransformations(transformations: Transformations): void {
		// 	this.transformationValidator.validateTransformations(transformations);
		// }
		if (!transformations) {
			return;
		}

		if (!transformations.GROUP || !transformations.APPLY) {
			throw new InsightError("TRANSFORMATIONS must have GROUP and APPLY");
		}

		this.validateGroup(transformations.GROUP);
		this.validateApply(transformations.APPLY);
	}

	private validateSort(sort: SortObject, columns: string[]): void {
		// this block of code is generated by AI
		if (typeof sort !== "object" || sort === null) {
			throw new InsightError("ORDER must be an object with dir and keys");
		}

		if (!sort.dir || (sort.dir !== "UP" && sort.dir !== "DOWN")) {
			throw new InsightError("Invalid sort direction. Must be 'UP' or 'DOWN'");
		}

		if (!sort.keys || !Array.isArray(sort.keys) || sort.keys.length === 0) {
			throw new InsightError("Sort keys must be a non-empty array");
		}

		sort.keys.forEach((key) => {
			if (!columns.includes(key)) {
				throw new InsightError(`ORDER key not in COLUMNS: ${key}`);
			}
		});
		// end of AI generated code block
	}

	private validateGroup(group: Group): void {
		// this block of code is largely generated by AI
		if (!group || !Array.isArray(Object.values(group)) || Object.values(group)[0].length === 0) {
			throw new InsightError("GROUP must contain a non-empty array");
		}

		const keyList = Object.values(group) as string[];
		keyList.forEach((key) => {
			const prefix = this.datasetID + "_";
			if (!this.isValidKey(key, prefix)) {
				throw new InsightError(`Invalid key in GROUP: ${key}`);
			}
		});
		// end of AI generated code block
	}

	private validateApply(apply: Apply): void {
		if (!apply || !Array.isArray(Object.values(apply)) || Object.values(apply)[0].length === 0) {
			throw new InsightError("APPLY must contain a non-empty array");
		}

		const applyKeys = new Set<string>();
		const applyRuleList = Object.values(apply) as ApplyRule[];
		applyRuleList.forEach((applyRule) => {
			this.validateApplyRule(applyRule as ApplyRule, applyKeys);
		});
	}

	private validateApplyRule(applyRule: ApplyRule, applyKeys: Set<string>): void {
		const applyValue = Object.entries(applyRule);

		if (applyValue.length !== 1) {
			throw new InsightError("APPLY doesn't have just one key-value pair");
		}

		const [applyKey, applyToken] = applyValue[0];
		if (applyKeys.has(applyKey)) {
			throw new InsightError(`applyKey appears more than once: ${applyKey}`);
		}
		applyKeys.add(applyKey);

		this.validateApplyToken(applyToken);
	}

	private validateApplyToken(applyToken: { [APPLYTOKEN: string]: string }): void {
		const applyTokenValue = Object.entries(applyToken);

		if (applyTokenValue.length !== 1) {
			throw new InsightError("APPLY token has more than one key");
		}

		const [applyTokenKey, key] = applyTokenValue[0];

		if (!APPLYTOKEN.has(applyTokenKey)) {
			throw new InsightError(`Invalid APPLYTOKEN: ${applyTokenKey}`);
		}

		const prefix = this.datasetID + "_";
		if (!this.isValidKey(key, prefix)) {
			throw new InsightError(`Invalid key in APPLY: ${key}`);
		}

		const field = key.substring(prefix.length);
		const numericTokens = new Set(["MAX", "MIN", "AVG", "SUM"]);

		if (numericTokens.has(applyTokenKey) && !this.isValidMField(field)) {
			throw new InsightError(`${applyTokenKey} can only be applied to numeric fields: ${key}`);
		}
	}

	private isValidKey(key: string, prefix: string): boolean {
		if (this.isValidApplyKey(key)) {
			return true;
		}

		if (!key.startsWith(prefix)) {
			return false;
		}
		const field = key.substring(prefix.length);
		return this.isValidMField(field) || this.isValidSField(field);
	}

	private isValidMField(field: string): boolean {
		const validMFields: ValidMFields[] = ["avg", "pass", "fail", "audit", "year", "lat", "lon", "seats"];
		return validMFields.includes(field as ValidMFields);
	}

	private isValidSField(field: string): boolean {
		const validSFields: ValidSFields[] = [
			"dept",
			"id",
			"instructor",
			"title",
			"uuid",
			"fullname",
			"shortname",
			"number",
			"name",
			"address",
			"type",
			"furniture",
			"href",
		];
		return validSFields.includes(field as ValidSFields);
	}

	private isValidApplyKey(key: string): boolean {
		// generated by AI tool
		return key.length > 0 && !key.includes("_");
		// end of AI generated code block
	}

	private validateColumnsWithTransformations(options: PossibleOption, transformations: Transformations): void {
		const columns = options.COLUMNS;
		const groupKeys = Object.values(transformations.GROUP);

		const validKeys = new Set<string>(groupKeys);

		const applyRules = Object.values(transformations.APPLY) as ApplyRule[];
		applyRules.forEach((applyRule) => {
			const applyKey = Object.keys(applyRule)[0];
			validKeys.add(applyKey);
		});

		columns.forEach((column) => {
			if (!validKeys.has(column)) {
				throw new InsightError(`Column not in GROUP or APPLY: ${column}`);
			}
		});
	}
}
